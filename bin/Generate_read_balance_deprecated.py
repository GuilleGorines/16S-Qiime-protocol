'''
=============================================================
HEADER
=============================================================
INSTITUTION: BU-ISCIII
AUTHOR: Guillermo J. Gorines Cordero
MAIL: guillermo.gorines@urjc.es
VERSION: 0
CREATED: 13-1-2022
REVISED: 
DESCRIPTION: 
    Ad-hoc script to get the read balance in a 16S protocol
INPUT:
    1. multiqc_data.json generated by multiqc data
OUTPUT:
    Balance of reads obtained in the whole service 
'''

import json
import sys

multiqc_json = sys.argv[1]
stats_file = sys.argv[2]

def clean_name(dirty_name):
    clean_name = dirty_name.replace("_R1","").replace("_R2","").replace("_adapter_removed","").replace("_filtered","")
    return clean_name

with open(multiqc_json,"r") as infile:
    mqc_json = json.load(infile)

read_data_dict = {}

# List with 3 dicts
for dictionary in mqc_json["report_general_stats_data"]:
       
    # key is the samplename, value is a dictionary containing dictionaries
    for key, value in dictionary.items():

        digested_samplename = clean_name(key)
        
        if digested_samplename not in read_data_dict.keys():
            read_data_dict[digested_samplename] = {}
            read_data_dict[digested_samplename]["Samplename"] = digested_samplename
        
        # adapter_removed is given to fastp
        if "_adapter_removed" in key:
            read_data_dict[digested_samplename]["Reads after Trimming"] = int(value['filtering_result_passed_filter_reads'])
        
        # no "_filtered" or no "_adapter_removed" means RAW, "_adapter_removed" means trimmed
        else:
            # 
            if "_R1" in key:
                if "_filtered" in key:
                    read_data_dict[digested_samplename]["R1 TRIMMED mean length"] = float(value['avg_sequence_length'])
                else:

                    if "pairs_processed" in value.keys():
                        read_data_dict[digested_samplename]["RAW reads"] = int(value['pairs_processed'])
                        read_data_dict[digested_samplename]["Reads after Cutadapt"] = int(value['pairs_written'])
                    else:
                        read_data_dict[digested_samplename]["R1 RAW mean length"] = float(value['avg_sequence_length'])
                
            if "_R2" in key:
                if "_filtered" in key:
                    read_data_dict[digested_samplename]["R2 TRIMMED mean length"] = float(value['avg_sequence_length'])
                else:
                    if "pairs_processed" in value.keys():
                        read_data_dict[digested_samplename]["RAW reads"] = int(value['pairs_processed'])
                        read_data_dict[digested_samplename]["Reads after Cutadapt"] = int(value['pairs_written'])

                    else:
                        read_data_dict[digested_samplename]["R2 RAW mean length"] = float(value['avg_sequence_length'])

with open(stats_file,"r") as statfile:
    statfile = statfile.readlines()
    statfile = [item.split("\t") for item in statfile[2:]]

for item in statfile:
    read_data_dict[item[0]]["Reads after Qiime2 filtering"] = int(item[2])
    read_data_dict[item[0]]["Reads after Qiime2 denoising"] = int(item[4])
    read_data_dict[item[0]]["Reads merged by Qiime2"] = int(item[5])
    read_data_dict[item[0]]["Non-chimeric merged reads"] = int(item[7])

# 0: Sample id
# 1: Raw reads
# 2: Reads after Cutadapt
# 3: Reads after Trimming
# 4: R1 raw mean length
# 5: R2 Raw mean length
# 6: R1 Trimmed mean length
# 7: R2 Trimmed mean length
# 8: Reads after Qiime2 filtering
# 9: Reads after Qiime2 denoising
# 10: Reads merged by Qiime2
# 11: Non-chimeric merged reads

with open("Read_balance.tsv","w") as outfile:
    headers_list = ["Sample id", "RAW Reads",
                    "Reads after Cutadapt","% of reads after Cutadapt",
                    "Reads after Trimming","% of reads after Trimming",
                    "R1 reads RAW mean length","R2 reads RAW mean length",
                    "R1 reads Trimmed mean length","R2 reads Trimmed mean length",
                    "Reads after Qiime2 filtering","% of reads after Qiime2 filtering",
                    "Reads after Qiime2 denoising","% of reads after Qiime2 denoising",
                    "Reads merged by Qiime2","% of merged reads after Qiime2",
                    "Non-chimeric merged reads","% of non-chimeric merged reads"]
    outfile.write("\t".join(headers_list))
    outfile.write("\n")

    for line in read_data_dict.values():
        samplename = line["Samplename"]
        raw = line["RAW reads"]

        after_cutadapt = line["Reads after Cutadapt"]
        after_cutadapt_percentage = after_cutadapt*100/raw

        # trimmomatic counts single reads instead of pairs
        after_trimmomatic = line["Reads after Trimming"]/2
        after_trimmomatic_percentage = after_trimmomatic*100/raw

        R1_raw = line["R1 RAW mean length"]
        R2_raw = line["R2 RAW mean length"]
        R1_trim = line["R1 TRIMMED mean length"]
        R2_trim = line["R2 TRIMMED mean length"]

        qiime_filtering = line["Reads after Qiime2 filtering"]
        qiime_filtering_percentage = qiime_filtering*100/raw

        qiime_denoising = line["Reads after Qiime2 denoising"]
        qiime_denoising_percentage = qiime_denoising*100/raw

        qiime_merged = line["Reads merged by Qiime2"]
        qiime_merged_percentage = qiime_merged*100/raw

        qiime_non_chimeric = line["Non-chimeric merged reads"]
        qiime_non_chimeric_percentage = qiime_non_chimeric*100/raw

        data_list = [samplename, raw, after_cutadapt, after_cutadapt_percentage,
                     after_trimmomatic, after_trimmomatic_percentage, R1_raw,
                     R2_raw, R1_trim, R2_trim, qiime_filtering, qiime_filtering_percentage,
                     qiime_denoising, qiime_denoising_percentage, qiime_merged,
                     qiime_merged_percentage, qiime_non_chimeric, 
                     qiime_non_chimeric_percentage]

        data_list = map(lambda x: str(x).replace(".",","),data_list)


        outfile.write("\t".join(data_list))
        outfile.write("\n")
